# Query
Create Notes about Graphs for CIS 350

# Output
```json
{"message":"# Notes on Graphs for CIS 350\n\n## What is a Graph?\n\nA **graph** is a pair (V, E), where:\n- **V** is a set of nodes called **vertices**\n- **E** is a collection of pairs of vertices called **edges**\n- Vertices and edges are positions that store elements\n\n**Example**: In a flight network, vertices represent airports (storing three-letter codes like ORD, LAX), and edges represent flight routes (storing mileage).\n\n---\n\n## Edge Types\n\n### Directed vs Undirected Edges\n\n**Directed Edge**:\n- Ordered pair of vertices (u,v)\n- First vertex u is the **origin**\n- Second vertex v is the **destination**\n- Example: a specific flight\n\n**Undirected Edge**:\n- Unordered pair of vertices (u,v)\n- Example: a flight route (bidirectional)\n\n**Directed Graph**: All edges are directed (e.g., route network)  \n**Undirected Graph**: All edges are undirected (e.g., flight network)\n\n---\n\n## Terminology\n\n**End vertices (endpoints)**: The two vertices connected by an edge\n\n**Incident edges**: Edges connected to a vertex\n\n**Adjacent vertices**: Two vertices connected by an edge\n\n**Degree of a vertex**: Number of edges incident on that vertex\n\n**Parallel edges**: Multiple edges connecting the same pair of vertices\n\n---\n\n## Paths and Cycles\n\n### Path\n- Sequence of alternating vertices and edges\n- Begins and ends with a vertex\n- Each edge is preceded and followed by its endpoints\n\n**Simple Path**: A path where all vertices and edges are distinct\n\n### Cycle\n- Circular sequence of alternating vertices and edges\n- Each edge is preceded and followed by its endpoints\n\n**Simple Cycle**: A cycle where all vertices and edges are distinct\n\n---\n\n## Graph Properties\n\n**Notation**:\n- n = number of vertices\n- m = number of edges\n- deg(v) = degree of vertex v\n\n**Property 1**: Σv deg(v) = 2m  \n*Proof*: Each edge is counted twice\n\n**Property 2**: In an undirected graph with no self-loops and no multiple edges:  \nm ≤ n(n-1)/2  \n*Proof*: Each vertex has degree at most (n-1)\n\n---\n\n## Graph ADT Methods\n\n### Accessor Methods\n- `e.endVertices()`: Returns list of two end vertices of edge e\n- `e.opposite(v)`: Returns the vertex opposite of v on edge e\n- `u.isAdjacentTo(v)`: Returns true if u and v are adjacent\n- `*v`: Reference to element associated with vertex v\n- `*e`: Reference to element associated with edge e\n\n### Update Methods\n- `insertVertex(o)`: Insert a vertex storing element o\n- `insertEdge(v, w, o)`: Insert an edge (v,w) storing element o\n- `eraseVertex(v)`: Remove vertex v and its incident edges\n- `eraseEdge(e)`: Remove edge e\n\n### Iterable Collection Methods\n- `incidentEdges(v)`: List of edges incident to v\n- `vertices()`: List of all vertices in the graph\n- `edges()`: List of all edges in the graph\n\n---\n\n## Graph Data Structures\n\n### 1. Edge List Structure\n\n**Vertex object**:\n- Element\n- Reference to position in vertex sequence\n\n**Edge object**:\n- Element\n- Origin vertex object\n- Destination vertex object\n- Reference to position in edge sequence\n\n**Sequences**:\n- Vertex sequence: sequence of vertex objects\n- Edge sequence: sequence of edge objects\n\n### 2. Adjacency List Structure\n\n- Built on edge list structure\n- **Incidence sequence** for each vertex: sequence of references to edge objects of incident edges\n- **Augmented edge objects**: references to associated positions in incidence sequences of end vertices\n\n### 3. Adjacency Matrix Structure\n\n- Built on edge list structure\n- **Augmented vertex objects**: Integer key (index) associated with vertex\n- **2D-array adjacency array**: \n  - Reference to edge object for adjacent vertices\n  - Null for non-adjacent vertices\n  - Traditional version uses 0 for no edge, 1 for edge\n\n---\n\n## Performance Comparison\n\nFor n vertices, m edges, no parallel edges, no self-loops:\n\n| Operation | Edge List | Adjacency List | Adjacency Matrix |\n|-----------|-----------|----------------|------------------|\n| **Space** | n + m | n + m | n² |\n| **v.incidentEdges()** | m | deg(v) | n |\n| **u.isAdjacentTo(v)** | m | min(deg(v), deg(u)) | 1 |\n| **insertVertex(o)** | 1 | 1 | n² |\n| **insertEdge(v,w,o)** | 1 | 1 | 1 |\n\n---\n\n## Applications\n\n- **Electronic circuits**: Printed circuit boards, integrated circuits\n- **Transportation networks**: Highway networks, flight networks\n- **Computer networks**: Local area networks, Internet, Web\n- **Databases**: Entity-relationship diagrams"}
```